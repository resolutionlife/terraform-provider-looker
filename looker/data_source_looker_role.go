package looker

import (
	"context"

	"github.com/hashicorp/go-multierror"
	"github.com/hashicorp/terraform-plugin-sdk/v2/diag"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	"github.com/resolutionlife/terraform-provider-looker/internal/conv"

	sdk "github.com/looker-open-source/sdk-codegen/go/sdk/v4"
)

func datasourceRole() *schema.Resource {
	return &schema.Resource{
		ReadContext: datasourceRoleRead,
		Importer: &schema.ResourceImporter{
			StateContext: schema.ImportStatePassthroughContext,
		},

		Schema: map[string]*schema.Schema{
			"name": {
				Type:         schema.TypeString,
				Optional:     true,
				ExactlyOneOf: []string{"name", "id"},
				Description:  "The name of the role. This field is case sensitive. See the documentation on looker [roles](https://docs.looker.com/admin-options/settings/roles) and [default roles](https://docs.looker.com/admin-options/settings/roles#default_roles) generated by Looker.",
			},
			"id": {
				Type:         schema.TypeString,
				Optional:     true,
				ExactlyOneOf: []string{"name", "id"},
				Description:  "The id of the role",
			},
			// TODO: Set up schema.Set for permission set
			// "permission_set": {
			// 	Type: schema.TypeMap,
			// 	Elem: &schema.Schema{
			// 		Type: schema.TypeString,
			// 	},
			// 	Computed:    true,
			// 	Description: "The permission set binded to the looker role. This permission_set object holds additional attributes about the permission set.",
			// },
			"model_set": {
				Type:        schema.TypeSet,
				Elem:        &schema.Resource{Schema: modelSetSchema()},
				Computed:    true,
				Description: "The model set binded to the looker role. This model_set object holds additional attributes about the model set",
			},
		},
	}
}

func modelSetSchema() map[string]*schema.Schema {
	return map[string]*schema.Schema{
		"name": {
			Type: schema.TypeString,
			// TODO: Why does this implemention panic when Computed: true?
			Optional:    true,
			Description: "The name of the model set. This field is case sensitive. Documentation on model sets can be found [here](https://docs.looker.com/admin-options/settings/roles#model_sets).",
		},
		"id": {
			Type: schema.TypeString,
			// TODO: Why does this implemention panic when Computed: true?
			Optional:    true,
			Description: "The id of the resource",
		},
		"models": {
			Type: schema.TypeList,
			Elem: &schema.Schema{
				Type: schema.TypeString,
			},
			Computed:    true,
			Description: "A list of models within the model set.",
		},
	}
}

func datasourceRoleRead(ctx context.Context, d *schema.ResourceData, c interface{}) diag.Diagnostics {
	api := c.(*sdk.LookerSDK)

	// exactly one of these variables will be nil - this is enforced by the data source schema
	name := conv.PString(d.Get("name").(string))
	id := conv.PString(d.Get("id").(string))

	roles, roleErr := api.SearchRoles(sdk.RequestSearchRoles{}, nil)
	if roleErr != nil {
		return diag.FromErr(roleErr)
	}

	var role *sdk.Role
	for _, r := range roles {
		if id != nil && r.Id != nil && *id == *r.Id {
			role = &r
		}

		if name != nil && r.Name != nil && *name == *r.Name {
			role = &r
		}
	}
	if role == nil {
		return diag.Errorf("role not found")
	}
	d.SetId(*role.Id)

	modelSet := schema.NewSet(schema.HashResource(&schema.Resource{Schema: modelSetSchema()}), []interface{}{})
	modelSet.Add(
		map[string]interface{}{
			"name":   toString(role.ModelSet.Name),
			"id":     toString(role.ModelSet.Id),
			"models": role.ModelSet.Models,
		},
	)

	result := multierror.Append(
		d.Set("name", role.Name),
		// d.Set("permission_set", role.PermissionSet),
		d.Set("model_set", modelSet),
	)

	return diag.FromErr(result.ErrorOrNil())
}

func toString(s *string) string {
	if s == nil {
		return ""
	}

	return *s
}
